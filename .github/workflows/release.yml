name: Release Deployment

on:
  workflow_run:
    workflows: ["Build and Release"]
    types:
      - completed
    branches:
      - master

jobs:
  release-deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all build artifacts
      uses: actions/github-script@v7
      with:
        script: |
          let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({
             owner: context.repo.owner,
             repo: context.repo.repo,
             run_id: ${{ github.event.workflow_run.id }},
          });
          let matchArtifacts = allArtifacts.data.artifacts.filter((artifact) => {
            return artifact.name.includes("release");
          });
          for (const artifact of matchArtifacts) {
            let download = await github.rest.actions.downloadArtifact({
               owner: context.repo.owner,
               repo: context.repo.repo,
               artifact_id: artifact.id,
               archive_format: 'zip',
            });
            let fs = require('fs');
            fs.writeFileSync(`${artifact.name}.zip`, Buffer.from(download.data));
          }

    - name: Extract and organize artifacts
      run: |
        echo "Creating release directory structure..."
        mkdir -p release/{macOS,Windows,Linux}

        # Extract artifacts if they exist
        for zip_file in *-release.zip; do
          if [ -f "$zip_file" ]; then
            echo "Extracting $zip_file..."
            unzip -q "$zip_file" -d temp_extract/

            # Copy contents to appropriate release folders
            if [ -d "temp_extract/macOS" ]; then
              cp -r temp_extract/macOS/* release/macOS/ 2>/dev/null || true
            fi
            if [ -d "temp_extract/Windows" ]; then
              cp -r temp_extract/Windows/* release/Windows/ 2>/dev/null || true
            fi
            if [ -d "temp_extract/Linux" ]; then
              cp -r temp_extract/Linux/* release/Linux/ 2>/dev/null || true
            fi

            # Clean up
            rm -rf temp_extract/
          fi
        done

        # Also handle the combined ssh-organizer-release artifact
        if [ -f "ssh-organizer-release.zip" ]; then
          echo "Extracting ssh-organizer-release.zip..."
          unzip -q "ssh-organizer-release.zip" -d ssh_organizer_release/

          # Copy all contents to release folder
          if [ -d "ssh_organizer_release" ]; then
            cp -r ssh_organizer_release/* release/ 2>/dev/null || true
          fi

          rm -rf ssh_organizer_release/
        fi

    - name: List and validate release contents
      run: |
        echo "=== Release Directory Contents ==="
        find release -type f -exec ls -lh {} \; | sort

        echo ""
        echo "=== Platform-specific Executables ==="

        echo "macOS executables:"
        find release/macOS -name "*.dmg" -o -name "*.zip" 2>/dev/null || echo "No macOS executables found"

        echo "Windows executables:"
        find release/Windows -name "*.exe" -o -name "*.msi" -o -name "*.zip" 2>/dev/null || echo "No Windows executables found"

        echo "Linux executables:"
        find release/Linux -name "*.AppImage" -o -name "*.tar.gz" -o -name "*.deb" -o -name "*.rpm" 2>/dev/null || echo "No Linux executables found"

        # Count files
        TOTAL_FILES=$(find release -type f | wc -l)
        echo ""
        echo "Total release files: $TOTAL_FILES"

        if [ $TOTAL_FILES -eq 0 ]; then
          echo "âš ï¸  Warning: No release files found!"
          exit 1
        else
          echo "âœ… Release files successfully organized"
        fi

    - name: Create release archive
      run: |
        echo "Creating release archive..."
        tar -czf ssh-organizer-release-$(date +%Y%m%d-%H%M%S).tar.gz -C release .

        # Also create platform-specific archives
        if [ -d "release/macOS" ] && [ "$(ls -A release/macOS)" ]; then
          tar -czf ssh-organizer-macos-$(date +%Y%m%d-%H%M%S).tar.gz -C release/macOS .
        fi

        if [ -d "release/Windows" ] && [ "$(ls -A release/Windows)" ]; then
          tar -czf ssh-organizer-windows-$(date +%Y%m%d-%H%M%S).tar.gz -C release/Windows .
        fi

        if [ -d "release/Linux" ] && [ "$(ls -A release/Linux)" ]; then
          tar -czf ssh-organizer-linux-$(date +%Y%m%d-%H%M%S).tar.gz -C release/Linux .
        fi

        echo "Archive contents:"
        ls -lh *.tar.gz

    - name: Upload final release artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ssh-organizer-final-release-${{ github.run_number }}
        path: |
          release/
          *.tar.gz
        retention-days: 180

    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action Release Bot"
        git config --local pull.rebase false

    - name: Create release branch
      run: |
        BRANCH_NAME="release/build-$(date +%Y%m%d-%H%M%S)"
        echo "RELEASE_BRANCH=$BRANCH_NAME" >> $GITHUB_ENV

        echo "Creating new branch: $BRANCH_NAME"
        git checkout -b $BRANCH_NAME

    - name: Commit release files to branch
      run: |
        # Add release files to git
        git add release/
        git add *.tar.gz

        # Create commit message with build info
        COMMIT_MSG="Add release files from build workflow

        ğŸ“¦ Release artifacts for commit: ${{ github.event.workflow_run.head_sha }}
        ğŸš€ Built from: ${{ github.event.workflow_run.head_branch }}
        ğŸ“… Build date: $(date)

        Platform-specific executables:
        $(find release -type f -name "*.dmg" -o -name "*.zip" -o -name "*.exe" -o -name "*.msi" -o -name "*.AppImage" -o -name "*.tar.gz" -o -name "*.deb" -o -name "*.rpm" 2>/dev/null | wc -l) files

        ğŸ¤– Generated by GitHub Actions Release Workflow"

        git commit -m "$COMMIT_MSG"

    - name: Push release branch
      run: |
        echo "Pushing branch: $RELEASE_BRANCH"
        git push origin $RELEASE_BRANCH

    - name: Create Pull Request
      id: create-pr
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const { data: pullRequest } = await github.rest.pulls.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `ğŸš€ Release Build Files - ${new Date().toISOString().split('T')[0]}`,
            head: process.env.RELEASE_BRANCH,
            base: 'master',
            body: `## ğŸ“¦ Release Build Files

          This PR contains the build artifacts from the latest successful build workflow.

          ### ğŸ”— Source Build
          - **Workflow Run**: [${{ github.event.workflow_run.id }}](${{ github.event.workflow_run.html_url }})
          - **Commit**: ${{ github.event.workflow_run.head_sha }}
          - **Branch**: ${{ github.event.workflow_run.head_branch }}

          ### ğŸ“ Release Contents
          - **macOS**: DMG and ZIP packages
          - **Windows**: EXE, MSI, and ZIP packages
          - **Linux**: AppImage, tar.gz, deb, and rpm packages

          ### ğŸ¤– Automated Process
          This PR was automatically created by the Release Deployment workflow.

          **Note**: Review the artifacts before merging to ensure build quality.`,
            draft: false
          });

          console.log(\`Pull request created: \${pullRequest.html_url}\`);

          // Store PR number for auto-merge
          core.setOutput('pr-number', pullRequest.number);
          core.setOutput('pr-url', pullRequest.html_url);

          return pullRequest.number;

    - name: Auto-merge Pull Request to Master
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const prNumber = ${{ steps.create-pr.outputs.result }};

          if (prNumber) {
            console.log(`Attempting to auto-merge PR #${prNumber}...`);
            console.log('Waiting 30 seconds before auto-merge...');
            await new Promise(resolve => setTimeout(resolve, 30000));

            try {
              // Merge the pull request to master
              const mergeResult = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                commit_title: `ğŸš€ Merge release build files`,
                commit_message: `Automatically merged release artifacts from build workflow

                Build artifacts from workflow run: ${{ github.event.workflow_run.id }}
                Source commit: ${{ github.event.workflow_run.head_sha }}

                ğŸ¤– Auto-merged by Release Deployment workflow`,
                merge_method: 'merge'
              });

              console.log(`Pull request #${prNumber} auto-merged successfully!`);
              console.log(`Merge commit SHA: ${mergeResult.data.sha}`);

              core.setOutput('merge-successful', 'true');
              core.setOutput('merge-sha', mergeResult.data.sha);

            } catch (error) {
              console.log('Auto-merge failed, manual review required:', error.message);
              core.setOutput('merge-successful', 'false');

              // Comment on the PR about the failed auto-merge
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `ğŸš¨ **Auto-merge failed**

                The release deployment workflow attempted to automatically merge this PR but failed.

                **Error**: ${error.message}

                Please review the changes and merge manually if appropriate.

                ğŸ¤– _This comment was automatically generated by the Release Deployment workflow_`
              });
            }
          } else {
            console.log('No PR number available for auto-merge');
          }

    - name: Clean up release branch (if auto-merged)
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          try {
            // Wait a moment for merge to complete
            await new Promise(resolve => setTimeout(resolve, 10000));

            // Delete the release branch
            await github.rest.git.deleteRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `heads/${process.env.RELEASE_BRANCH}`
            });

            console.log(\`Deleted release branch: \${process.env.RELEASE_BRANCH}\`);
          } catch (error) {
            console.log('Branch cleanup failed (branch may still be in use):', error.message);
          }

    - name: Summary
      run: |
        echo "ğŸ‰ Release deployment completed successfully!"
        echo ""
        echo "ğŸ“¦ Release artifacts created and committed to repository"
        echo "ğŸŒ¿ Branch created: $RELEASE_BRANCH"
        echo "ğŸ“‹ Pull request created for review and merge"
        echo ""
        echo "ğŸ“ Release files organized in:"
        echo "  - release/macOS/ (DMG, ZIP files)"
        echo "  - release/Windows/ (EXE, MSI, ZIP files)"
        echo "  - release/Linux/ (AppImage, tar.gz, deb, rpm files)"
        echo ""
        echo "âœ… Files are now available in the repository after merge!"